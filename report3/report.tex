\documentclass[a4paper,10pt]{article}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage[margin=1in]{geometry}
\usepackage{enumitem}

\usepackage[nottoc]{tocbibind}
\usepackage{fancyvrb} 
\usepackage{float}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{color}
\usepackage{booktabs}
\usepackage{listings}

\title{Combinatorial Optimization\\Homework 3 – Experimental Measurements}
\author{Matyáš Skalický\\skalimat@fit.cvut.cz}

\begin{document}
\maketitle
\tableofcontents
\medskip


\section{Measured Algorithms}

Baseline exact method is the \textbf{brute-force} algorithm that simply iterates all possible solutions without any speedups.

The \textbf{branch\&bound} extends the brute-force with 2 speedups. We stop when the current candidate already exceeds the capacity of a bag. Also, we don't recurse further when the cost sum of the items that can be added into the bag is lower than the best found solution.

The dynamic programming approach is based on the \textbf{decomposition by cost}. This solution is based on memoization by the recursive function calls by returning the maximum value from the tested branches on return.

The \textbf{greedy} heuristic simply adds the items with the highest cost/weight ratio until the capacity of the bag is reached. This is the only algorithm that doesn't always result in the optimal solution.

\section{Measured Variables}
For the pilot experiments, I've chosen to benchmark all algorithms on the instances of size $24$. The generator's maximum weight $W$ is set to $3000$ as well as maximum price $C$.

In the following experiments, we will try to measure how time and the solution quality depend on the generator inputs. Also, we will look how robust each algorithm is against permutations in the algorithm inputs.

\begin{itemize}
	\item Ratio of bag capacity to summary weight. (\lstinline{cw_ratio} $\in [0, 2]$)
	\item Correlation between price and weight. (\lstinline{pw_corr} $\in [0, 1]$)
	\item Granularity and distribution of weights. (\lstinline{w_dist} $\in [0, 2]$)
\end{itemize}

\clearpage

\section{Experiments}
We will measure the effect of each variable separately. We will generate 10 problem instances for each algorithm with each weight.

\subsection{Robustness}
First, we will try to answer the robustness (invariance to order of input items) of each algorithm. We will use default generator values mentioned above. We will generate 500 instances and calculate 10 permutations for each algorithm. We will calculate the variance in the elapsed time across the 10 permutations and take a mean across all instances.

\begin{table}[!htb]
\centering
\begin{tabular}{lrr}
method & mean runtime & mean runtime variance\\
\midrule
greedy heuristic & 0.00006964 & 0.00000001 \\
branch\&bound & 0.00642724 & 0.00001817 \\
dynamic (cost) & 0.38064328 & 0.01843123 \\
bruteforce   & 9.22061772 & 1.95676123 \\
\bottomrule
\end{tabular}
\caption{Mean of runtime (seconds) and runtime variance over 10 permutations}
\end{table}

It is not surprising, that the heuristic is extremely stable as it is basically just one pass over the items in the bag. I have expected that the algorithms such as branch\&bound and dynamic would be less robust as especially the first one depends on the order of items while pruning. Yet the dynamic algorithm seems to be not very robust as well.

It is surprising that the bruteforce algorithm shows such huge mean variance in the measured runtime. But it is also worth noting that the mean runtime for bruteforce was $9.22$ seconds while it was only $0.38$ and $0.006$ seconds for dynamic and branch\&bound respectively.

I would say, that since the measured metric was the runtime and the experiments were performed on a 40-core CPU in parallel, it could be caused by uneven load across CPU cores as different tasks were running on the CPU as well. But I still find it very interesting.

\subsection{Pilot Experiments}

 We will not measure the permutations in the pilot experiments. Figure \ref{pilot_figure} contains the absolute Pearson correlation between the runtime in seconds and changing parameters in the instance generator.

\begin{figure}[!htb]
	\centering
  	\includegraphics[width=\textwidth]{images/pilot.png}
	\caption{Correlation of the algorithm runtime to the change in parameters}
	\label{pilot_figure}
\end{figure}

\subsection{Detailed Experiments}

Based on the Figure \ref{pilot_figure}, we can see that there is a strong correlation between \emph{dynamic} and \lstinline{cw_ratio}. We will further inspect the relation of \emph{dynamic} and \lstinline{w_dist}. For the \emph{branch\&bound}, we will inspect the variables \lstinline{cw_ratio} and \lstinline{pw_corr} as they has shown a small correlation with the algorithm runtime.

All variables were tested separately, 100 samples per each testing instance size.

\subsubsection{Weight Distribution (w\_dist)}

As expected by the pilot experiments, the weight distribution does not heavily affect the elapsed time.

\begin{figure}[!htb]
	\centering
  	\includegraphics[width=\textwidth]{images/wdist.png}
	\caption{Weight distribution vs. experiment runtime}
	\label{wdist}
\end{figure}

\subsubsection{Capacity and Weight Ratio (cw\_ratio)}

\begin{figure}[!htb]
	\centering
  	\includegraphics[width=\textwidth]{images/cwratio.png}
	\caption{Capacity and weight ratio vs. experiment runtime}
	\label{cwratio}
\end{figure}

\subsubsection{Price and Weight Correlation (pw\_corr)}

\begin{figure}[!htb]
	\centering
  	\includegraphics[width=\textwidth]{images/pwcorr.png}
	\caption{Price and Weight Correlation vs. experiment runtime}
	\label{pwcorr}
\end{figure}

\section{Discussion and Takeoffs}


\end{document}